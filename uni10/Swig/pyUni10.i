%module pyUni10

%{
  /* Put header files here or function declarations like below */
  #define SWIG_FILE_WITH_INIT
  #include <sstream>
  #include <complex>
  #include <uni10/datatype/Qnum.h>
  #include <uni10/data-structure/Bond.h>
  #include <uni10/data-structure/Block.h>
  #include <uni10/tensor-network/Matrix.h>
  #include <uni10/tensor-network/UniTensor.h>
  #include <uni10/tensor-network/Network.h>
%}

%begin %{
  #ifdef _MSC_VER
    #define SWIG_PYTHON_INTERPRETER_NO_DEBUG
  #endif
%}



%include "numpy.i"

%include "std_vector.i"
%include "std_map.i"
%include "std_string.i"
%include "std_complex.i"
%include "exception.i"
/*%include "typemaps.i"*/

%numpy_typemaps(std::complex<float>, NPY_CFLOAT, int)
%numpy_typemaps(std::complex<double>, NPY_CDOUBLE, int)

%inline%{
  typedef double Real;
  typedef std::complex<double> Complex;
%}
namespace std{
  %template(int_arr) vector<int>;
  %template(double_arr) vector<double>;
  %template(complex_arr) vector<Complex>;
  %template(Qnum_arr) vector<uni10::Qnum>;
  %template(Bond_arr) vector<uni10::Bond>;
  %template(Qnum2int) map<uni10::Qnum, int>;
  %template(Matrix_arr) vector<uni10::Matrix>;
  %template(Qnum2Block) std::map<uni10::Qnum, uni10::Block>;
  %template(Qnum2Matrix) std::map<uni10::Qnum, uni10::Matrix>;
  /*%template(Swap_arr)  std::vector<uni10::_Swap>;*/
}
%init %{
    import_array();
%}

%apply (double* ARGOUT_ARRAY1, int DIM1) {(double* out_array, int elem_num)}
%feature("autodoc");

%exception {
    try {
      $action
    } catch (const std::exception &e) {
      std::string s("\nException raised by pyUni10: "), s2(e.what());
        s = s + s2;
        SWIG_exception(SWIG_RuntimeError, s.c_str());
    } catch (...) {
        SWIG_exception(SWIG_RuntimeError, "unknown exception");
    }
}

%inline{
  uni10::Qnum QnumF(uni10::parityFType _prtF, int _U1=0, uni10::parityType _prt=uni10::PRT_EVEN){
    return uni10::Qnum(_prtF, _U1, _prt);
  }
  uni10::Block CBlock(size_t _Rnum, size_t _Cnum, bool _diag = false){
      return uni10::Block(uni10::CTYPE, _Rnum,  _Cnum, _diag );
  }
  uni10::Matrix CMatrix( size_t _Rnum, size_t _Cnum, bool _diag=false, bool _ongpu=false){
      return uni10::Matrix(uni10::CTYPE,_Rnum, _Cnum, _diag, _ongpu);
  }
  uni10::Matrix CMatrix(const std::string& fname){
      return uni10::Matrix(uni10::CTYPE, fname);
  }
};

namespace uni10{
/* Qnum */
enum parityType{
  PRT_EVEN = 0,
  PRT_ODD = 1
};
enum parityFType{
  PRTF_EVEN = 0,
  PRTF_ODD = 1
};
typedef struct{
        int b1;
        int b2;
}_Swap;

class Qnum {
  public:
      Qnum(int _U1 = 0, parityType _prt = PRT_EVEN);
      /*Qnum(parityFType _prtF, int _U1 = 0, parityType _prt = PRT_EVEN);*/
      Qnum(const Qnum& _q);
      ~Qnum(){};
      int U1()const;
      parityType prt()const;
      parityFType prtF()const;
      void assign(int _U1 = 0, parityType _prt = PRT_EVEN);
      /*void assign(parityFType _prtF, int _U1 = 0, parityType _prt = PRT_EVEN);*/
      static bool isFermionic(){return Fermionic;}
      /*
         friend bool operator< (const Qnum& q1, const Qnum& q2);
         friend bool operator<= (const Qnum& q1, const Qnum& q2);
         friend bool operator== (const Qnum& q1, const Qnum& q2);
         friend Qnum operator* (const Qnum& q1, const Qnum& q2);
         friend Qnum operator- (const Qnum& q1);
         friend std::ostream& operator<< (std::ostream& os, const Qnum& q);
       */
      %extend {
          /*
          bool __eq__(const Qnum& q2){
              return (*self) == q2;
          }*/
          int __cmp__(const Qnum& q2){
            if((*self) < q2)
              return -1;
            else if((*self) == q2)
              return 0;
            else
              return 1;
          }
          long __hash__(){
            return (*self).hash();
          }
          Qnum __mul__(const Qnum& q2){
              return (*self) * q2;
          }
          Qnum __neg__(){
              return -(*self);
          }
          Qnum __copy__(){
              return (*self);
          }
          const std::string __repr__() {
              std::ostringstream oss(std::ostringstream::out);
              oss << (*self);
              return oss.str();
          }
          Qnum& assignF(parityFType _prtF, int _U1 = 0, parityType _prt = PRT_EVEN){
              self->assign(_prtF, _U1, _prt);
              return *self;
          }

      }
      /* Make Qnum Class immutable */
      static const int U1_UPB = 1000;//Upper bound of U1
      static const int U1_LOB = -1000;//Lower bound of U1
};
/* End of Qnum */

/* Bond */
enum bondType{
  BD_IN = 1,
  BD_OUT = -1
};

class Bond {
  public:
      /*Bond(){};*/
      Bond(bondType _type, int dim);
      Bond(bondType, const std::vector<Qnum>& qnums);
      Bond(const Bond& _b);
      void assign(bondType, int dim);
      void assign(bondType, const std::vector<Qnum>& qnums);
      bondType type()const;
      int dim()const;
      std::map<Qnum, int> degeneracy()const;
      std::vector<Qnum> Qlist()const;
      void change(bondType tp);
      Bond& combine(const Bond bd);
      /*
      friend bool operator== (const Bond& b1, const Bond& b2);
      friend Bond combine(bondType tp, const std::vector<Bond>& bds);
      friend Bond combine(const std::vector<Bond>& bds);
      friend std::ostream& operator<< (std::ostream& os, const Bond& b);
      friend class UniTensor;
      friend class Node;
      */
      %extend {
          bool __eq__(const Bond& b2){
              return (*self) == b2;
          }
          Bond __copy__(){
              return (*self);
          }
          const std::string  __repr__() {
              std::ostringstream oss(std::ostringstream::out);
              oss << (*self);
              return oss.str();
          }
      }
      ~Bond();
};
extern Bond combine(bondType tp, const std::vector<Bond>& bds);
extern Bond combine(const std::vector<Bond>& bds);
/* End of Bond */

/* Block */


enum rflag{
  RNULL = 0,
  RTYPE = 1
};

enum cflag{
  CNULL = 0,
  CTYPE = 2
};

class Matrix;
class Block{
  public:
    Block();
    Block(size_t _Rnum, size_t _Cnum, bool _diag = false);
    Block(const Block& _b);
    virtual ~Block();
    size_t row()const;
    size_t col()const;
    bool isDiag()const;
    bool isOngpu()const;
    size_t elemNum()const;
    int typeID()const;
    void save(const std::string& fname)const;
    std::vector<Matrix> qr()const;
    std::vector<Matrix> rq()const;
    std::vector<Matrix> ql()const;
    std::vector<Matrix> lq()const;
    std::vector<Matrix> svd()const;
    std::vector<Matrix> eig()const;
    std::vector<Matrix> eigh()const;
    Matrix inverse()const;
    Real norm()const;
    Matrix getDiag()const;
    Real trace()const;
    Real sum()const;
    Real at(size_t i, size_t j)const;
    bool CelemIsNULL()const;
    bool RelemIsNULL()const;
    Real* getElem()const;
    /* deafult is real, so rflag is ignored for conflict with cflag */
    //Block(cflag _tp, size_t _Rnum, size_t _Cnum, bool _diag = false);
    void save(cflag _tp, const std::string& fname)const;
    std::vector<Matrix> qr(cflag _tp)const;
    std::vector<Matrix> rq(cflag _tp)const;
    std::vector<Matrix> ql(cflag _tp)const;
    std::vector<Matrix> lq(cflag _tp)const;
    std::vector<Matrix> svd(cflag _tp)const;
    std::vector<Matrix> eig(cflag _tp)const;
    std::vector<Matrix> eigh(cflag _tp)const;
    Matrix inverse(cflag _tp)const;
    Real norm(cflag _tp)const;
    Matrix getDiag(cflag _tp)const;
    Complex trace(cflag _tp)const;
    Complex sum(cflag _tp)const;
    /*Complex operator()(size_t idx)const;*/
    Complex at(cflag _tp, size_t i, size_t j)const;
    Complex* getElem(cflag _tp)const;

    %extend {
      bool __eq__(const Block& b2){
        return (*self) == b2;
      }
      Block __copy__(){
        return (*self);
      }
      const std::string __repr__() {
        std::ostringstream oss(std::ostringstream::out);
        oss << (*self);
        return oss.str();
      }
      Matrix __mul__(const Block& Ma){
        return (*self) * Ma;
      }
      Matrix __add__(const Block& Ma){
        return (*self) + Ma;
      }
      Matrix __mul__(double a){
        return a * (*self);
      }
      Matrix __rmul__(double a){
        return a * (*self);
      }

    }
};

/* End of Block */


/* Matrix */

class Matrix: public Block {


  public:
    double absMax(bool _ongpu=false);
    Matrix& maxNorm();
    Matrix& absMaxNorm();
//    double* getHostElem();
//    std::complex<double>* getHostElem(cflag _tp);
    Matrix();
    Matrix(size_t _Rnum, size_t _Cnum, bool _diag=false, bool _ongpu=false);
    Matrix(std::string tp, size_t _Rnum, size_t _Cnum, bool _diag=false, bool _ongpu=false);
    Matrix(const Matrix& _m);
    Matrix(const Block& _b);
    Matrix(const std::string& fname);
    ~Matrix();
    void identity();
    void set_zero();
    void randomize();
    void orthoRand();
    Matrix& normalize();
    Matrix& transpose();
    Matrix& cTranspose();
    Matrix& conj();
    Matrix& resize(size_t row, size_t col);
    double max(bool _ongpu=false);
    void assign(size_t _Rnum, size_t _Cnum);
    void load(const std::string& fname);
    bool toGPU();

    Matrix(size_t _Rnum, size_t _Cnum, const double* _elem, bool _diag=false, bool _ongpu=false, bool src_ongpu=false);
    Matrix(size_t _Rnum, size_t _Cnum, const std::vector<double>& _elem, bool _diag=false, bool _ongpu = false, bool src_ongpu=false);
    void setElem(const double* elem, bool src_ongpu = false);
    void setElem(const std::vector<double>& elem, bool src_ongpu = false);
    Matrix(size_t _Rnum, size_t _Cnum, const std::complex<double>* _elem, bool _diag=false, bool _ongpu=false, bool src_ongpu=false);
    Matrix(size_t _Rnum, size_t _Cnum, const std::vector< std::complex<double> >& _elem, bool _diag=false, bool _ongpu=false, bool src_ongpu=false);
//    Matrix(cflag _tp, const std::string& fname);
//    Matrix(cflag _tp, size_t _Rnum, size_t _Cnum, bool _diag=false, bool _ongpu=false);
    void setElem(const std::complex<double>* elem, bool src_ongpu = false);
    void setElem(const std::vector< std::complex<double> >& elem, bool src_ongpu = false);
    void identity(cflag _tp);
    void set_zero(cflag _tp);
    void randomize(cflag _tp);
    void orthoRand(cflag _tp);
    Matrix& normalize(cflag tp);
    Matrix& transpose(cflag _tp);
    Matrix& cTranspose(cflag _tp);
    Matrix& conj(cflag _tp);
    Matrix& resize(cflag _tp, size_t row, size_t col);
    //std::complex<double>& operator()(size_t idx); //&
    std::complex<double>& at(cflag _tp, size_t i); //&
    void assign(cflag _tp, size_t _Rnum, size_t _Cnum);
    bool toGPU(cflag _tp);


    %extend {
      bool __eq__(const Matrix& b2){
        return (*self) == b2;
      }
      Matrix __copy__(){
        return (*self);
      }
      const std::string __repr__() {
        std::ostringstream oss(std::ostringstream::out);
        oss << (*self);
        return oss.str();
      }
      Matrix __mul__(const Matrix& Ma){
        return (*self) * Ma;
      }
      Matrix __add__(const Matrix& Ma){
        return (*self) + Ma;
      }
      Matrix __mul__(double a){
        return a * (*self);
      }
      Matrix __rmul__(double a){
        return a * (*self);
      }

      PyObject* __getitem__(PyObject *parm) {
          switch ((*self).typeID()) {
              case uni10::CTYPE:
                  if (PyTuple_Check(parm)){
                      long r,c;
                      r=PyInt_AsLong(PyTuple_GetItem(parm,0));
                      c=PyInt_AsLong(PyTuple_GetItem(parm,1));
                      if( (*self).isDiag() && r!=c) {
                          if (r>=(*self).col()){
                            PyErr_SetString(PyExc_IndexError, "Index out of bound.");
                            return NULL;
                          }
                          return PyComplex_FromDoubles(0.0,0.0);
                      } else {
                          return PyComplex_FromDoubles((*self)(r).real(),
                                                       (*self)(r).imag());
                      }
                  } else if (PyInt_Check(parm)) {
                      return PyComplex_FromDoubles((*self)(PyInt_AsLong(parm)).real(),
                                                   (*self)(PyInt_AsLong(parm)).imag());
                  }
                  break;
              case uni10::RTYPE:
                  if (PyTuple_Check(parm)){
                      long r,c;
                      r=PyInt_AsLong(PyTuple_GetItem(parm,0));
                      c=PyInt_AsLong(PyTuple_GetItem(parm,1));
                      if( (*self).isDiag() && r!=c) {
                        if (r>=(*self).col()){
                          PyErr_SetString(PyExc_IndexError, "Index out of bound.");
                          return NULL;
                        }
                        return PyFloat_FromDouble(0.0);
                      } else {
                        return PyFloat_FromDouble((*self)[r]);
                      }
                  } else if (PyInt_Check(parm)) {
                      return PyFloat_FromDouble((*self)[PyInt_AsLong(parm)]);
                  }
                  break;
              default:
                  return Py_None;

          }
      }

      void __setitem__(PyObject *parm, Complex val){
        switch ((*self).typeID()) {
          case uni10::CTYPE:
              if (PyTuple_Check(parm)){
                  long r,c;
                  r=PyInt_AsLong(PyTuple_GetItem(parm,0));
                  c=PyInt_AsLong(PyTuple_GetItem(parm,1));
                  if( (*self).isDiag()) {
                      if (r==c) {
                        if (r>=(*self).col()){
                          PyErr_SetString(PyExc_IndexError, "Index out of bound.");
                        }
                        (*self)(r)=val;
                      } else {
                          PyErr_SetString(PyExc_IndexError,
                            "Can not assign off-diagnonal elements for diagonal matrix.");
                      }
                  } else {
                      (*self)(r*(*self).col()+c)=val;
                  }
              } else if (PyInt_Check(parm)) {
                  (*self)(PyInt_AsLong(parm))=val;
              }
              break;
          case uni10::RTYPE:
              if (PyTuple_Check(parm)){
                    long r,c;
                    r=PyInt_AsLong(PyTuple_GetItem(parm,0));
                    c=PyInt_AsLong(PyTuple_GetItem(parm,1));
                    if( (*self).isDiag()) {
                        if (r==c) {
                          if (r>=(*self).col()){
                            PyErr_SetString(PyExc_IndexError, "Index out of bound.");
                          }
                          (*self)[r]=val.real();
                        } else {
                          PyErr_SetString(PyExc_IndexError,
                            "Can not assign off-diagnonal elements for diagonal matrix.");
                        }
                    } else {
                        (*self)[r*(*self).col()+c]=val.real();
                    }
              } else if (PyInt_Check(parm)) {
                    (*self)[PyInt_AsLong(parm)]=val.real();
              }
              break;
          default:
                std::ostringstream err;
                err<<"\nCan not assign value to Null matrix.\n";
                throw std::runtime_error(err.str());
        }
      }

    /*PyObject* nparray(){
      switch ((*self).typeID()) {
        case uni10::RTYPE:
          if((*self).isDiag()){
            npy_intp dims[1]={static_cast<npy_intp>( (*self).col())};
            return PyArray_SimpleNewFromData((*self).elemNum(),dims,NPY_FLOAT,(*self).getElem());
          } else {
            npy_intp dims[2]={static_cast<npy_intp>((*self).col()),static_cast<npy_intp>((*self).row())};
            return PyArray_SimpleNewFromData((*self).elemNum(),dims,NPY_FLOAT,(*self).getElem());
          }

          break;
        case uni10::CTYPE:
          if((*self).isDiag()){
            npy_intp dims[1]={static_cast<npy_intp>( (*self).col())};
            return PyArray_SimpleNewFromData((*self).elemNum(),dims,NPY_CDOUBLE,(*self).getElem(uni10::CTYPE));
          } else {
            npy_intp dims[2]={static_cast<npy_intp>((*self).col()),static_cast<npy_intp>((*self).row())};
            return PyArray_SimpleNewFromData((*self).elemNum(),dims,NPY_CDOUBLE,(*self).getElem(uni10::CTYPE));
          }

          break;
        default:
          return Py_None;
      }
    }*/

  }

};
Matrix takeExp(double a, const Block& mat);
Matrix otimes(const Block& Ta, const Block& Tb);

/* End of Matrix */


/*class UniTensor;*/
class UniTensor{
  public:

        double max() const;

        double absMax() const;

        UniTensor& maxNorm();

        UniTensor& absMaxNorm();

        double norm() const;
        double norm(cflag tp) const;
        /*
        UniTensor& normalize();
        double max(rflag tp) const;
        double absMax(rflag tp) const;
        UniTensor& maxNorm(rflag tp);
        UniTensor& absMaxNorm(rflag tp);
        double norm(rflag tp) const;
        UniTensor& normalize(rflag tp);
        UniTensor& normalize(cflag tp);
        */
        void printDiagram()const;

        std::vector<UniTensor> hosvd(int* group_labels, int* groups, size_t groupsSize, std::vector<Matrix>& Ls)const ;
        std::vector<UniTensor> hosvd(int* group_labels, int* groups, size_t groupsSize, std::vector<std::map<Qnum, Matrix> >& Ls, bool returnL)const ;
        std::vector<UniTensor> hosvd(std::vector<int>& group_labels, std::vector<int>& groups, std::vector<Matrix>& Ls)const ;
        std::vector<UniTensor> hosvd(std::vector<int>& group_labels, std::vector<int>& groups, std::vector<std::map<Qnum, Matrix> >& Ls, bool returnL)const ;

        std::vector<UniTensor> hosvd(cflag tp, int* group_labels, int* groups, size_t groupsSize, std::vector<Matrix>& Ls)const ;
        std::vector<UniTensor> hosvd(cflag tp, int* group_labels, int* groups, size_t groupsSize, std::vector<std::map<Qnum, Matrix> >& Ls, bool returnL)const ;
        std::vector<UniTensor> hosvd(cflag tp, std::vector<int>& group_labels, std::vector<int>& groups, std::vector<Matrix>& Ls)const ;
        std::vector<UniTensor> hosvd(cflag tp, std::vector<int>& group_labels, std::vector<int>& groups, std::vector<std::map<Qnum, Matrix> >& Ls, bool returnL)const ;

        std::vector<UniTensor> hosvd(size_t modeNum, size_t fixedNum = 0)const;
        std::vector<UniTensor> hosvd(size_t modeNum, size_t fixedNum, std::vector<std::map<Qnum, Matrix> >& Ls)const;
        std::vector<UniTensor> hosvd(size_t modeNum, size_t fixedNum, std::vector<Matrix>& Ls)const;
        std::vector<UniTensor> hosvd(cflag tp, size_t modeNum, size_t fixedNum = 0)const;
        std::vector<UniTensor> hosvd(cflag tp, size_t modeNum, size_t fixedNum, std::vector<std::map<Qnum, Matrix> >& Ls)const;
        std::vector<UniTensor> hosvd(cflag tp, size_t modeNum, size_t fixedNum, std::vector<Matrix>& Ls)const;
        UniTensor& cTranspose();
        UniTensor& cTranspose(cflag tp);
        UniTensor();
        UniTensor(const std::vector<Bond>& _bonds, const std::string& _name = "");
        UniTensor(const std::string tp, const std::vector<Bond>& _bonds, const std::string& _name = "");
        UniTensor(const std::vector<Bond>& _bonds, std::vector<int>& labels, const std::string& _name = "");
        UniTensor(const std::vector<Bond>& _bonds, int* labels, const std::string& _name = "");
        UniTensor(const UniTensor& UniT);
        UniTensor(const std::string& fname);
        #ifdef HDF5
        UniTensor(const std::string& fname, const bool hdf5);
        #endif
        UniTensor(const Block& UniT);
        ~UniTensor();
        void setRawElem(const Block& blk);
        void putBlock(const Block& mat);
        void putBlock(const Qnum& qnum, const Block& mat);
        int typeID()const;
        void setLabel(const int newLabel, const size_t idx);
        void setLabel(const std::vector<int>& newLabels);
        void setLabel(int* newLabels);
        std::vector<int> label()const;
        int label(size_t idx)const;
        std::string getName() const;
        void setName(const std::string& _name);
        size_t bondNum()const;
        size_t inBondNum()const;
        std::vector<Bond> bond()const;
        Bond bond(size_t idx)const;
        size_t elemNum()const;
        size_t blockNum()const;
        std::vector<Qnum> blockQnum()const;
        Qnum blockQnum(size_t idx)const;
        const std::map<Qnum, Block>& const_getBlocks()const;
        const Block& const_getBlock()const;
        const Block& const_getBlock(const Qnum& qnum)const;
        std::map<Qnum, Matrix> getBlocks()const;
        Matrix getBlock(bool diag = false)const;
        Matrix getBlock(const Qnum& qnum, bool diag = false)const;
        void set_zero();
        void set_zero(const Qnum& qnum);
        void identity();
        void identity(const Qnum& qnum);
        void randomize();
        void orthoRand();
        void orthoRand(const Qnum& qnum); 
        void save(const std::string& fname) const;
        #ifdef HDF5
        void h5save(const std::string& fname);
        #endif
        UniTensor& transpose();
        UniTensor& permute(const std::vector<int>& newLabels, int inBondNum);
        UniTensor& permute(int* newLabels, int inBondNum);
        UniTensor& permute(int inBondNum);
        UniTensor& combineBond(const std::vector<int>& combined_labels);
        static std::string profile(bool );
        //std::vector<_Swap> exSwap(const UniTensor& Tb)const;
        //void addGate(const std::vector<_Swap>& swaps);
        std::complex<double> trace()const;
        UniTensor& partialTrace(int la, int lb);
        Matrix getRawElem()const;
        UniTensor& assign(const std::vector<Bond>& _bond);
        bool CelemIsNULL();
        bool RelemIsNULL();
        bool similar(const UniTensor& Tb)const;
        bool elemCmp(const UniTensor& UniT)const;
        void clear();

        UniTensor(double val);
        void setRawElem(const std::vector<double>& rawElem);
        void setRawElem(const double* rawElem);
        void setElem(const double* elem, bool _ongpu = false);
        void setElem(const std::vector<double>& elem, bool _ongpu = false);

        UniTensor(std::complex<double> val);
        UniTensor(cflag tp, const std::vector<Bond>& _bonds, const std::string& _name = "");
        UniTensor(cflag tp, const std::vector<Bond>& _bonds, std::vector<int>& labels, const std::string& _name = "");
        UniTensor(cflag tp, const std::vector<Bond>& _bonds, int* labels, const std::string& _name = "");
        //void setRawElem(const std::vector< std::complex<double> >& rawElem);
        //void setRawElem(const std::complex<double>* rawElem);
        void setRawElem(cflag tp, const Block& blk);
        void putBlock(cflag tp, const Block& mat);
        void putBlock(cflag tp, const Qnum& qnum, const Block& mat);
        void setElem(const std::complex<double>* c_elem, bool _ongpu = false);
        void setElem(const std::vector< std::complex<double> >& c_elem, bool _ongpu = false);
        std::map<Qnum, Matrix> getBlocks(cflag tp)const;
        Matrix getBlock(cflag tp, bool diag = false)const;
        Matrix getBlock(cflag tp, const Qnum& qnum, bool diag = false)const;
        void set_zero(cflag tp);
        void set_zero(cflag tp, const Qnum& qnum);
        void identity(cflag tp);
        void identity(cflag tp, const Qnum& qnum);
        void randomize(cflag tp);
        void orthoRand(cflag tp);
        void orthoRand(cflag tp, const Qnum& qnum);
        UniTensor& transpose(cflag tp);
        UniTensor& permute(cflag tp, const std::vector<int>& newLabels, int inBondNum);
        UniTensor& permute(cflag tp, int* newLabels, int inBondNum);
        UniTensor& permute(cflag tp, int inBondNum);
        UniTensor& combineBond(cflag tp, const std::vector<int>& combined_labels);
        void addGate(cflag tp, const std::vector<_Swap>& swaps);
        std::complex<double>* getElem(cflag tp);
        Matrix getRawElem(cflag tp)const;
        std::complex<double> trace(cflag tp)const;
        UniTensor& partialTrace(cflag tp, int la, int lb);
        UniTensor& assign(cflag tp, const std::vector<Bond>& _bond);

        double at(size_t idx)const;
        double at(const std::vector<int>& idxs)const;
        double at(const std::vector<size_t>& idxs)const;
        std::complex<double> at(cflag tp, size_t idx)const;
        std::complex<double> at(cflag tp, const std::vector<int>& idxs)const;
        std::complex<double> at(cflag tp, const std::vector<size_t>& idxs)const;
        double* getElem();
        void exportElem(double* out_array, int elem_num);
        /*Complex operator()(size_t idx) const;*/

    %extend {
      UniTensor __copy__(){
        return (*self);
      }
      const std::string __repr__() {
        std::ostringstream oss(std::ostringstream::out);
        oss << (*self);
        return oss.str();
      }
      UniTensor __mul__(const UniTensor& Ta){
        return (*self) * Ta;
      }
      UniTensor __add__(const UniTensor& Ta){
        return (*self) + Ta;
      }
      UniTensor __mul__(double a){
        return a * (*self);
      }
      UniTensor __rmul__(double a){
        return a * (*self);
      }
      PyObject* __getitem__(PyObject *parm) {
          switch ((*self).typeID()) {
              case uni10::CTYPE:
                  if (PyInt_Check(parm)) {
                      return PyComplex_FromDoubles((*self)(PyInt_AsLong(parm)).real(),
                            (*self)(PyInt_AsLong(parm)).imag());
                  }
                  break;
              case uni10::RTYPE:
                  if (PyInt_Check(parm)) {
                      return PyFloat_FromDouble((*self)[PyInt_AsLong(parm)]);
                  }
                  break;
              default:
                  return Py_None;
          }
      }
      static const std::string profile(){
        return uni10::UniTensor::profile(false);
      }
      const std::string printRawElem(){
        return (*self).printRawElem(false);
      }
      void setRawElemC(const std::complex<double>* elem, bool src_ongpu = false){
        (*self).setRawElem(elem);
      }
      void setRawElemC(const std::vector< std::complex<double> >& elem, bool src_ongpu = false){
        (*self).setRawElem(elem);
      }

    }
    /*
       std::vector<UniTensor> hosvd(rflag tp, int* group_labels, int* groups, size_t groupsSize, std::vector<Matrix>& Ls)const ;
       std::vector<UniTensor> hosvd(rflag tp, std::vector<int>& group_labels, std::vector<int>& groups, std::vector<Matrix>& Ls)const ;
       std::vector<UniTensor> hosvd(rflag tp, int* group_labels, int* groups, size_t groupsSize, std::vector<std::map<Qnum, Matrix> >& Ls, bool returnL)const ;
       std::vector<UniTensor> hosvd(rflag tp, std::vector<int>& group_labels, std::vector<int>& groups, std::vector<std::map<Qnum, Matrix> >& Ls, bool returnL)const ;
       std::vector<UniTensor> hosvd(rflag tp, size_t modeNum, size_t fixedNum = 0)const;
       std::vector<UniTensor> hosvd(rflag tp, size_t modeNum, size_t fixedNum, std::vector<std::map<Qnum, Matrix> >& Ls)const;
       std::vector<UniTensor> hosvd(rflag tp, size_t modeNum, size_t fixedNum, std::vector<Matrix>& Ls)const;
       UniTensor& operator*= (double a);
       UniTensor& operator*= (std::complex<double> a);
       UniTensor& operator*= (const UniTensor& Tb);
       friend UniTensor operator*(const UniTensor& Ta, const std::complex<double>& a);
       friend UniTensor operator*(const std::complex<double>& a, const UniTensor& Ta);
       friend UniTensor operator*(const UniTensor& Ta, double a);
       friend UniTensor operator*(double a, const UniTensor& Ta);
       friend UniTensor operator*(const UniTensor& Ta, const UniTensor& Tb);
       UniTensor& operator=(const UniTensor& UniT);
       UniTensor& operator+= (const UniTensor& Tb);
       friend UniTensor operator+ (const UniTensor& Ta, const UniTensor& Tb);
       friend UniTensor contract(UniTensor& Ta, UniTensor& Tb, bool fast);
       friend UniTensor otimes(const UniTensor& Ta, const UniTensor& Tb);
       std::string printRawElem(bool print=true)const;
       UniTensor(rflag tp, const std::vector<Bond>& _bonds, const std::string& _name = "");
       UniTensor(rflag tp, const std::vector<Bond>& _bonds, std::vector<int>& labels, const std::string& _name = "");
       UniTensor(rflag tp, const std::vector<Bond>& _bonds, int* labels, const std::string& _name = "");
       void setRawElem(rflag tp, const Block& blk);
       void putBlock(rflag tp, const Block& mat);
       void putBlock(rflag tp, const Qnum& qnum, const Block& mat);
       void set_zero(rflag tp);
       void set_zero(rflag tp, const Qnum& qnum);
       void identity(rflag tp);
       void identity(rflag tp, const Qnum& qnum);
       void randomize(rflag tp);
       void orthoRand(rflag tp);
       void orthoRand(rflag tp, const Qnum& qnum);
       std::map<Qnum, Matrix> getBlocks(rflag tp)const;
       Matrix getBlock(rflag tp, bool diag = false)const;
       Matrix getBlock(rflag tp, const Qnum& qnum, bool diag = false)const;
       UniTensor& transpose(rflag tp);
       UniTensor& permute(rflag tp, const std::vector<int>& newLabels, int inBondNum);
       UniTensor& permute(rflag tp, int* newLabels, int inBondNum);
       UniTensor& permute(rflag tp, int inBondNum);
       friend UniTensor contract(rflag tp, UniTensor& Ta, UniTensor& Tb, bool fast);
       friend UniTensor otimes(rflag tp, const UniTensor& Ta, const UniTensor& Tb);
       UniTensor& combineBond(rflag tp, const std::vector<int>& combined_labels);
       void addGate(rflag tp, const std::vector<_Swap>& swaps);
       double* getElem(rflag tp);
       Matrix getRawElem(rflag tp)const;
       UniTensor& partialTrace(rflag tp, int la, int lb);
       UniTensor& assign(rflag tp, const std::vector<Bond>& _bond);
       friend UniTensor contract(cflag tp, UniTensor& Ta, UniTensor& Tb, bool fast);
       friend UniTensor otimes(cflag tp, const UniTensor& Ta, const UniTensor& Tb);
       double at(rflag tp, size_t idx)const;
       double at(rflag tp, const std::vector<int>& idxs)const;
       double at(rflag tp, const std::vector<size_t>& idxs)const;
       double operator[](size_t idx) const;
       std::complex<double> operator()(size_t idx) const;

     */
};
UniTensor contract(UniTensor& Ta, UniTensor& Tb, bool fast=false);
UniTensor contract(cflag tp, UniTensor& Ta, UniTensor& Tb, bool fast = false);
UniTensor otimes(const UniTensor& Ta, const UniTensor& Tb);
UniTensor otimes(cflag tp, const UniTensor& Ta, const UniTensor& Tb);
/* End of UniTensor */

/* class Network */
class Network {
  public:
    Network(const std::string& fname, const std::vector<UniTensor*>& tens);
    Network(const std::string& fname);
    ~Network();
    void putTensor(int idx, const UniTensor& UniT, bool force=true);
    void putTensor(const std::string& name, const UniTensor& UniT, bool force=true);
    void putTensorT(const std::string& nameT, const UniTensor& UniT, bool force=true);
    UniTensor launch(const std::string& name="");
    /*void profile();*/
    /*friend std::ostream& operator<< (std::ostream& os, Network& nd);*/
    %extend {
      Network __copy__(){
        return (*self);
      }
      const std::string __repr__() {
        std::ostringstream oss(std::ostringstream::out);
        oss << (*self);
        return oss.str();
      }
      const std::string profile() {
        return (*self).profile(false);
      }
    }
};
/* End of Network */


};
